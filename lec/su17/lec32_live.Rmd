---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
from datascience import *
import numpy as np

import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
# %matplotlib inline

from ipywidgets import interact, interactive, fixed, interact_manual
import ipywidgets as widgets
```

## Discussion

```{python}
x_avg = 70
x_sd = 10
y_avg = 50
y_sd = 12
r = 0.75
```

```{python}
# 90 on midterm
(90 - 70) / 10
```

```{python}
r * 2.0
```

```{python}
1.5 * y_sd + y_avg
```

```{python}
# 60 on midterm
(60 - 70) / 10
```

```{python}
r * -1.0
```

```{python}
-0.75 * y_sd + y_avg
```

## Linear regression

```{python}
def standard_units(any_numbers):
    "Convert any array of numbers to standard units."
    return (any_numbers - np.mean(any_numbers)) / np.std(any_numbers)  

def correlation(t, x, y):
    """Return the correlation coefficient (r) of two variables."""
    return np.mean(standard_units(t.column(x)) * standard_units(t.column(y)))
```

```{python}
def slope(t, x, y):
    """The slope of the regression line (original units)"""
    r = correlation(t, x, y)
    return r * np.std(t.column(y)) / np.std(t.column(x))

def intercept(t, x, y):
    """The intercept of the regression line (original units)"""
    return np.mean(t.column(y)) - slope(t, x, y) * np.mean(t.column(x))
```

## Least squares

```{python}
little_women = Table.read_table('http://inferentialthinking.com/notebooks/little_women.csv')
little_women = little_women.move_to_start('Periods')
little_women.show(3)
```

```{python}
little_women.scatter(0, 1)
```

```{python}
correlation(little_women, 'Periods', 'Characters')
```

```{python}
def fit(t, x, y):
    """Return the predicted y-value for each x-value"""
    a = slope(t, x, y)
    b = intercept(t, x, y)
    return a * t.column(x) + b
```

```{python}
little_women.with_column(
    'Fitted', fit(little_women, 0, 1)
).scatter('Periods')
```

```{python}
sample = [[131, 14431], [231, 20558], [392, 40935], [157, 23524]]
def lw_errors(slope, intercept):
    print('Slope:    ', np.round(slope), 'characters per period')
    print('Intercept:', np.round(intercept), 'characters')
    little_women.scatter('Periods', 'Characters')
    xlims = np.array([50, 450])
    plt.plot(xlims, slope * xlims + intercept, lw=2)
    for x, y in sample:
        plt.plot([x, x], [y, slope * x + intercept], color='r', lw=2)
```

```{python}
lw_reg_slope = slope(little_women, 0, 1)
lw_reg_intercept = intercept(little_women, 0, 1)
lw_errors(lw_reg_slope, lw_reg_intercept)
```

```{python}
lw_errors(50, 10000)
```

```{python}
lw_errors(-100, 50000)
```

```{python}
def lw_rmse(slope, intercept):
    lw_errors(slope, intercept)
    x = little_women.column('Periods')
    y = little_women.column('Characters')
    fitted = slope * x + intercept
    return np.sqrt(np.mean((y - fitted) ** 2))
```

```{python}
lw_rmse(50, 10000)
```

```{python}
lw_rmse(-100, 50000)
```

```{python}
lw_rmse(90, 4000)
```

```{python}
lw_rmse(lw_reg_slope, lw_reg_intercept)
```

## Numerical Optimization

```{python}
def lw_mse(any_slope, any_intercept):
    x = little_women.column(0)
    y = little_women.column(1)
    fitted = any_slope*x + any_intercept
    return np.mean((y - fitted) ** 2)
```

```{python}
lw_mse(90, 4000)
```

```{python}
np.sqrt(lw_mse(90, 4000))
```

```{python}
def f(x):
    return (x - 3) ** 2 + 1
```

```{python}
[f(1), f(2), f(3), f(4), f(5)]
```

```{python}
minimize(f)
```

```{python}
lw_mse(90, 4000)
```

```{python}
minimize(lw_mse)
```

```{python}
make_array(lw_reg_slope, lw_reg_intercept)
```

## Non-linear regression

```{python}
shotput = Table.read_table('http://inferentialthinking.com/notebooks/shotput.csv')
shotput.show(3)
```

```{python}
shotput.scatter(0, fit_line=True)
```

$$ a x + b $$


Try to find the best quadratic curve:

$$
a x ^ 2 + bx + c
$$

```{python}
def shotput_quad_mse(a, b, c):
    x = shotput.column(0)
    y = shotput.column(1)
    fitted = a*x**2 + b * x + c
    return np.mean((y - fitted) ** 2)
```

```{python}
best = minimize(shotput_quad_mse)
best
```

```{python}
a, b, c = best
a, b, c
```

```{python}
a, b, c = best
x = shotput.column(0)
quad_fitted = a*x**2 + b * x + c
quad_fitted
```

```{python}
shotput.with_column('Best Quad', quad_fitted).scatter(0)
```

```{python}

```
