---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python deletable=TRUE, editable=TRUE}
from datascience import *
import numpy as np

import matplotlib.pyplot as plots
from mpl_toolkits.mplot3d import Axes3D
plots.style.use('fivethirtyeight')
# %matplotlib inline
```

<!-- #region {"deletable": true, "editable": true} -->
## Defining a classifier
<!-- #endregion -->

```{python deletable=TRUE, editable=TRUE}
patients = Table.read_table('breast-cancer.csv').drop('ID')
patients.show(5)
```

```{python deletable=TRUE, editable=TRUE}
patients.scatter('Bland Chromatin', 'Single Epithelial Cell Size', colors='Class')
```

```{python deletable=TRUE, editable=TRUE}
def randomize_column(a):
    return a + np.random.normal(0.0, 0.09, size=len(a))

jittered = Table().with_columns([
        'Bland Chromatin (jittered)', 
        randomize_column(patients.column('Bland Chromatin')),
        'Single Epithelial Cell Size (jittered)', 
        randomize_column(patients.column('Single Epithelial Cell Size')),
        'Class',
        patients.column('Class')
    ])

jittered.scatter(0, 1, colors='Class')
```

<!-- #region {"deletable": true, "editable": true} -->
## Distance
<!-- #endregion -->

```{python deletable=TRUE, editable=TRUE}
def distance(pt1, pt2):
    """The distance between two points, represented as arrays."""
    return np.sqrt(sum((pt1 - pt2) ** 2))

def row_distance(row1, row2):
    """The distance between two rows of a table."""
    return distance(np.array(row1), np.array(row2))
```

```{python deletable=TRUE, editable=TRUE}
attributes = patients.drop('Class')
attributes.show(3)
```

```{python deletable=TRUE, editable=TRUE}
row_distance(attributes.row(0), attributes.row(1))
```

```{python deletable=TRUE, editable=TRUE}
row_distance(attributes.row(0), attributes.row(0))
```

```{python deletable=TRUE, editable=TRUE}
row_distance(attributes.row(0), attributes.row(2))
```

<!-- #region {"deletable": true, "editable": true} -->
## Classification Procedure
<!-- #endregion -->

```{python deletable=TRUE, editable=TRUE}
def distances(training, example):
    """Compute the distance from example for each row in training."""
    dists = []
    attributes = training.drop('Class')
    for row in attributes.rows:
        dists.append(row_distance(row, example))
    return training.with_column('Distance', dists)

def closest(training, example, k):
    """Return a table of the k closest neighbors to example."""
    return distances(training, example).sort('Distance').take(np.arange(k))
```

```{python deletable=TRUE, editable=TRUE}
patients.take(12)
```

```{python deletable=TRUE, editable=TRUE}
example = patients.drop('Class').row(12)
example
```

```{python deletable=TRUE, editable=TRUE}
closest(patients.exclude(12), example, 5)
```

```{python deletable=TRUE, editable=TRUE}
def majority_class(top_k):
    """Return the class with the highest count."""
    return top_k.group('Class').sort('count', descending=True).column(0).item(0)

def classify(training, example, k):
    """Return the majority class among the k nearest neighbors."""
    return majority_class(closest(training, example, k))
```

```{python deletable=TRUE, editable=TRUE}
classify(patients.exclude(12), example, 5)
```

<!-- #region {"deletable": true, "editable": true} -->
## Evaluation
<!-- #endregion -->

```{python deletable=TRUE, editable=TRUE}
patients.num_rows
```

```{python deletable=TRUE, editable=TRUE}
shuffled = patients.sample(with_replacement=False) # Randomly permute the rows
trainset = shuffled.take(range(342))
testset  = shuffled.take(range(342, 683))
```

```{python deletable=TRUE, editable=TRUE}
def evaluate_accuracy(training, test, k):
    test_attributes = test.drop('Class')
    numcorrect = 0
    for i in range(test.num_rows):
        # Run the classifier on the ith patient in the test set
        c = classify(training, test_attributes.row(i), k)
        # Was the classifier's prediction correct?
        if c == test.column('Class').item(i):
            numcorrect = numcorrect + 1
    return numcorrect / test.num_rows
```

```{python deletable=TRUE, editable=TRUE}
evaluate_accuracy(trainset, testset, 5)
```

```{python}
evaluate_accuracy(trainset, testset, 1)
```

```{python deletable=TRUE, editable=TRUE}
evaluate_accuracy(trainset, trainset, 5)
```

```{python deletable=TRUE, editable=TRUE}
evaluate_accuracy(trainset, trainset, 1)
```

## Decision boundaries

```{python}
ckd = Table.read_table('ckd.csv').relabeled('Blood Glucose Random', 'Glucose')
ckd.show(3)
```

```{python}
kidney = ckd.select('Hemoglobin', 'Glucose', 'Class')
kidney.scatter(0, 1, colors=2)
plots.scatter(13, 250, color='red', s=30)
```

```{python}
def show_closest(t, point):
    """Show closest training example to a point."""
    near = closest(t, point, 1).row(0)
    t.scatter(0, 1, colors='Class')
    plots.scatter(point.item(0), point.item(1), color='red', s=30)
    plots.plot([point.item(0), near.item(0)], [point.item(1), near.item(1)], color='k', lw=2)

show_closest(kidney, make_array(13, 250))
```

```{python}
def standard_units(any_numbers):
    "Convert any array of numbers to standard units."
    return (any_numbers - np.mean(any_numbers)) / np.std(any_numbers)  

def standardize(t):
    """Return a table in which all columns of t are converted to standard units."""
    t_su = Table()
    for label in t.labels:
        t_su = t_su.with_column(label + ' (su)', standard_units(t.column(label)))
    return t_su
```

```{python}
kidney_su = standardize(kidney.drop('Class')).with_column('Class', kidney.column('Class'))
show_closest(kidney_su, make_array(-0.2, 1.8))
```

```{python}
show_closest(kidney_su, make_array(-0.2, 1.3))
```

```{python}
show_closest(kidney_su, make_array(-0.2, 1))
```

```{python}
show_closest(kidney_su, make_array(-0.2, 0.9))
```

```{python}
def decision_boundary(t, k):
    """Decision boundary of a two-column + Class table."""
    t_su = standardize(t.drop('Class')).with_column('Class', t.column('Class'))
    decisions = Table(t_su.labels)
    for x in np.arange(-2, 2.1, 0.1):
        for y in np.arange(-2, 2.1, 0.1):
            predicted = classify(t_su, make_array(x, y), k)
            decisions.append([x, y, predicted])
    decisions.scatter(0, 1, colors='Class', alpha=0.4)
    plots.xlim(-2, 2)
    plots.ylim(-2, 2)
    t_su_0 = t_su.where('Class', 0)
    t_su_1 = t_su.where('Class', 1)
    plots.scatter(t_su_0.column(0), t_su_0.column(1), c='darkblue', edgecolor='k')
    plots.scatter(t_su_1.column(0), t_su_1.column(1), c='gold', edgecolor='k')
    
decision_boundary(kidney, 1)
```

```{python}
decision_boundary(kidney, 5)
```

```{python}
decision_boundary(jittered, 1)
```

```{python}
decision_boundary(jittered, 5)
```
