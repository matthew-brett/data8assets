---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

<!-- #region -->
# Midterm Review 5: Little Women

# URL: bit.ly/d8review5
# Word: summer



In the first lecture of this class, we analyzed the text of the 19th century novel Little Women.  We're going to perform a similar analysis.

We start by loading a table called `little_women`.  It contains 1 row for each time a word appears in the book.  (So if the word "Christmas" appears 50 times in the whole book, there will be 50 different rows for "Christmas" in `little_women`.)  It has 3 columns:
* `word`, the word itself
* `chapter`, the number of the chapter in which the word appears (the book's chapters start from 1)
* `word's index in chapter`, the number of words that came before the word in its chapter

# 1.
The word "morning" is the 17th word in chapter 2.  Chapter 1 had 4954 words in it.  Which of these does the corresponding row in `little_women` look like?

a.
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-yw4l{vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-yw4l">morning</th>
    <th class="tg-yw4l">2</th>
    <th class="tg-yw4l">17</th>
  </tr>
</table>

b.
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-yw4l{vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-yw4l">morning</th>
    <th class="tg-yw4l">1</th>
    <th class="tg-yw4l">17</th>
  </tr>
</table>

c.
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-yw4l{vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-yw4l">morning</th>
    <th class="tg-yw4l">2</th>
    <th class="tg-yw4l">16</th>
  </tr>
</table>

d.
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-yw4l{vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-yw4l">morning</th>
    <th class="tg-yw4l">1</th>
    <th class="tg-yw4l">16</th>
  </tr>
</table>

e.
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-yw4l{vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-yw4l">morning</th>
    <th class="tg-yw4l">2</th>
    <th class="tg-yw4l">4971</th>
  </tr>
</table>

f.
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-yw4l{vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-yw4l">morning</th>
    <th class="tg-yw4l">1</th>
    <th class="tg-yw4l">4970</th>
  </tr>
</table>

**Answer:** c.

For reference, here are some rows from the actual table:
<!-- #endregion -->

```{python}
# These lines import the Numpy and Datascience modules.
import numpy as np
from datascience import *

# These lines do some fancy plotting magic.
import matplotlib
# %matplotlib inline
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
import warnings
warnings.simplefilter('ignore', FutureWarning)

little_women = Table.read_table("little_women.csv")
little_women.show(5)
little_women.where("chapter", 2).show(20)
```

The word is in chapter 2.  The description of the `chapter` column said that the chapters start from 1 (not 0, like an index would), so chapter 2 will just have a 2.

The word is the 17th word in chapter 2.  That means 16 words came before it in its chapter.


# 2.
Suppose you wanted to count the number of words in each chapter.  Which line of code would do that?

(Recall that the function `np.count_nonzero` takes an array as its argument and returns the number of elements in the array that are either `True` or a number other than 0.)

a. `little_women.group("word")`

b. `little_women.group("chapter")`

c. `little_women.group("word's index in chapter")`

d. `little_women.group("word", np.sum)`

e. `little_women.where("word", "chapter")`

f. `little_women.pivot("word", "chapter")`

g. `np.count_nonzero(little_women.column("chapter"))`

h. None of these would work.


**Answer:** b.

This is a straightforward use of `group`: when we give it just a column name, it counts the number of times each different value appears in that column.


Suppose you wanted to count the number of times each character's name appears in each chapter.  You decide to do this by writing the following code:

```{python}
# This is an array of some of the main characters in the book.
CHARACTER_NAMES = np.array(['Jo', 'Meg', 'Amy', 'Beth', 'Laurie'])

def is_name(word):
    """
    Returns True if word is a name of a major character in
    Little Women (listed above), and False otherwise.
    
    word should be a string, an English word.
    """
    ... # You'll fill this in in question 3.

only_names = little_women.where(little_women.apply(is_name, ['word']))
character_count_by_chapter = only_names.pivot('word', 'chapter')
character_count_by_chapter
```

# 3.
What should go in the body of the function `is_name` above to make it work like its documentation says it does?

(Recall that the function `np.any` takes an array of boolean values as its argument and returns the single boolean value `True` if any elements of the array are `True`, returning `False` if none of them are `True`.  The function `np.all` takes an array of boolean values as its argument and returns the single boolean value `True` if all elements of the array are `True`, returning `False` if at least one is `False`.)

a. `return CHARACTER_NAMES == word`

b. `return CHARACTER_NAMES.item(i) == word`

c. `return np.any(CHARACTER_NAMES == word)`

d. `return np.all(CHARACTER_NAMES == word)`

e. `return np.all(CHARACTER_NAMES)`

f. `return CHARACTER_NAMES.item(word)`

g. None of these would work.


**Answer:** c.

It helps to break down these things into simpler components and understand each one.  `CHARACTER_NAMES` is an array of character names, and `word` is a single string (like "the" or "Jo").  So the expression `CHARACTER_NAMES == word` is performing an elementwise comparison: Its value is an array of length `len(CHARACTER_NAMES)`, where the first value is `True` if `word` was equal to "Jo", the second value is `True` if `word` was equal to "Meg", and so on.

Now, calling `np.any` on that array of boolean values will give us the value `True` if any of the values in that array are `True`.  In English, it will be `True` if `word` was equal to at least one character's name.  That's what we want.


# 4.
Many chapters focus on one character to the exclusion of others.  Suppose we have a function called `correlation` that computes the correlation between two arrays of numbers of equal length.  Would you guess the value of the line in this cell:

```{python}
correlation(character_count_by_chapter.column('Amy'), character_count_by_chapter.column('Meg'))
```

to be:

a. Positive

b. Negative

c. Around 0

d. (The given information doesn't tell us anything about this question.)


**Answer:** b (Negative).

First let's make a scatter plot just to picture what the data might look like.  You didn't have access to the actual data when answering the question.

```{python}
character_count_by_chapter.scatter('Amy', 'Meg')
```

When one character appears a lot of times in a chapter, that tends to mean the chapter focuses on that character, which leaves less time for other characters to appear.  So we'd expect one character to appear less when another appears more.  That means the correlation between Amy's appearances by chapter and Meg's appearances by chapter is probably negative.  (With the benefit of the actual data, we can see that that's actually true!)


# 5.
Around chapter 30, Amy and Laurie fall in love and marry.  Would you guess the value of the second line in this cell:

```{python}
after_30 = character_count_by_chapter.where(character_count_by_chapter.column('chapter') > 30)
correlation(after_30.column('Amy'), after_30.column('Laurie'))
```

to be:

a. Positive

b. Negative

c. Around 0

d. (The given information doesn't tell us anything about this question.)


**Answer:** a (Positive).

The logic we used in question 4 doesn't really apply if two characters often appear together and less often appear separately, as we'd reasonably expect for characters who are falling in love.  When Amy is mentioned a lot in a chapter, Laurie is probably there, too.  So the correlation is likely positive.

(Before chapter 30, when the characters aren't romantically involved, the correlation is much smaller.)
