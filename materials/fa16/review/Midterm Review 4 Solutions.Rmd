---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Midterm Review 4
# 1. `where_not`
If `t` is a table and `"c"` is the name of one of its columns, then `t.where("c", 3)` produces a smaller table containing rows of `t` where column `c` has value 3.  You decide to make it just as easy to make a table of all the rows where a column is something *other than* a given value.  You write a function called `where_not` to do it.  Its definition starts like this:

```{python}
def where_not(original_table, column_name, value):
    """
    Returns a new table that's like original_table, but without
    any rows where column_name is equal to value.
    """
    return ...
```

Fill in the "`...`".


**Answer:**

    original_table.where(original_table.column(column_name) != value)

If you have a hard time with this kind of problem, it might help to think of a specific case.  Suppose you have a table `t` with several columns, including one called `State`.  You want a table that doesn't include the rows where the `State` column is "California".  You would then write:

    t.where(t.column("State") != "California")

Our function just generalizes this so that `t`, `"State"`, and `"California"` could be anything.  To begin generalizing, imagine that you'd defined variables for all the information you needed to write your expression:

    state_to_remove = "California"
    column_name = "State"

Then you would have written:

    t.where(t.column(column_name) != state_to_remove)

If you were writing your own function, you could use those variable names and define it as:

    def where_not(t, column_name, state_to_remove):
        return t.where(t.column(column_name) != state_to_remove)

That's the same as our answer, except that some of the names of the arguments are different.


# 2. What would Python print?
What will be printed when the following cell is run?

```{python}
print("1")

def func2(arg):
    print("2")
    print(arg)

def func3():
    print("3")
    return "return value of func3"

print("4")
func2(func3())
```

**Answer:** 1; 4; 3; 2; return value of func3 (separated by semicolons instead of lines for brevity)

Pretend that you're Python running this code.  You just go through it line by line and run things.
1. You get to `print("1")`.  So you print 1.
2. You get to `def func2(arg):`.  So you define a function called `func2` that will execute the subsequent lines under it if it's called.  For now, no one has called `func2`, so nothing inside it happens, and in particular, nothing gets printed.
3. The same happens for `def func3():`.
4. You get to `print("4")`.  You print 4.

So the answer should definitely start with 1 and then 4.  Now it gets a little tricky.  Does the stuff in `func2` or `func3` happen first?  You could read the Python spec, but that's not the point of the question.  Instead, reason a bit about how Python would have to work.

We know that `func3` returns something when we call it, and `func2` is going to use that value (calling it `arg`) when it runs.  So Python *must* run `func3` first, to compute that value for `func2` to use.

That means that we first encounter `print("3")`, and then `func3` finishes by returning the aptly-named string `"return value of func3"`.

Then `func2` is called, with the argument `"return value of func3"`.  It first prints 2.  Then it prints the value of the argument.  Then it's done (and it returns nothing), and we're done with the cell.


# 3. `np.array`, part 1
In baseball, pitchers tend to throw slower fastballs as they get older.  Suppose we are trying to use linear regression to predict fastball speed using age.  We use 6 pitchers with known ages and fastball speeds to test out our model.

In the following code, is the call to `np.array` necessary for the code to work, or is it unnecessary but harmless, or does it cause the code not to work?

```{python}
ages = [21, 22, 23, 24, 25, 30]
regression_slope = -.25
regression_intercept = 101
predicted_speeds = np.array(ages) * regression_slope + regression_intercept
```

**Answer:** Necessary.

Python understands operators like `*` differently for different types of objects.  `ages` in this example is a list.  Multiplying a list by 2 will copy it twice and squash together the copies into one list:

```{python}
[1, 2, 5] * 2
```

This is useful in some circumstances.  But in this case, we want to multiply each element of `ages` by `regression_slope`.  (It wouldn't even make sense to multiply an array by `-.25`.)  To get that behavior, we need to use an array, not a list.  So converting `ages` from a list to an array is necessary.


# 4. `np.array`, part 2
Assume you've run the code in the previous cell (perhaps without the call to `np.array` if you said it caused it not to work).  Now suppose you set `true_speeds` to an *array* of the true fastball speeds of the 6 pitchers, and then run this code.

In the next cell, is the call to `np.array` necessary for the code to work, or is it unnecessary but harmless, or does it cause the code not to work?

```{python}
residuals = predicted_speeds - true_speeds
sum_squared_residuals = sum(np.array(residuals)**2)
```

**Answer:** Unnecessary but harmless.

When you multiply an array by something, or add it to a number or another array, the result is a new array.  It would be annoying if you got back a list, because then you'd have to always be converting things back to arrays to do more arithmetic on them.

Since `predicted_speeds` is an array, and `true_speeds` is also an array, `predicted_speeds - true_speeds` is an array.  So converting it to an array by writing `np.array(residuals)` is unnecessary.

It doesn't break anything, though, because converting an array to an array just gives you back a copy of the array.

This would have been an unnecessarily mean question to ask on an exam, but it **is** important to understand that
* objects have types,
* different types of objects can behave differently, and
* you can sometimes convert an object from one type to another.
