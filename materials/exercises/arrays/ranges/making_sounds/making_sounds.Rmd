---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

## Making Sounds

```{python}
# Run this cell to set up the notebook, but please don't change it.

# These lines import the Numpy and Datascience modules.
import numpy as np
from datascience import *

# These lines do some fancy plotting magic.
import matplotlib
# %matplotlib inline
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
import warnings
warnings.simplefilter('ignore', FutureWarning)

# These lines load the tests.
from client.api.assignment import load_assignment 
tests = load_assignment('making_sounds.ok')
```

Let's use arrays (and your computer's speakers) to generate sounds!

##### Brief background on sound
Sound happens when an object moves back-and-forth very quickly, pushing the air around it and creating rapidly oscillating increases and decreases in that air's pressure.  These patterned disturbances in the air move outward in all directions from the object (at the "speed of sound").

[This webpage](https://auditoryneuroscience.com/acoustics/sound_propagation) has a nice visual depiction of a sound.

When a disturbance in the air reaches your ear, your ear detects the air pressure changing at a certain rate, and you hear a particular sound.  Which sound you hear depends on how quickly the pressure goes up and down.  Simple, repeated oscillations sound like single musical *notes* to humans.  If the pressure goes up and down 220 times per second, you hear a note musicians call "A below middle C".

Note that the changes in air pressure that your brain interprets as sound are very *small* and *fast* relative to the kinds of pressure you can feel, say, on your skin.  Ears are sensitive, specialized instruments for detecting small, fast oscillations in pressure.


##### Simulating the pressure pattern of a sound
To generate a sound, then, we have to simulate pressure changes that would cause you to hear that sound.  Computer speakers take instructions like "make the pressure X at time Y," so we will to calculate those pressures.  Let's generate A below middle C for 3 seconds.

First, notice that we can't calculate the pressure at every point in time, because there are infinitely many points in time!

Instead, we'll just pick a bunch of points in time, and find out the pressure on your ear at those snapshots in time.  These snapshots are called *frames*.  In a video, a sequence of still pictures creates the illusion of continuous movement.  In the same way, your brain interprets a quick sequence of different pressures as a continuous sound.

Let's say we'll use 44100 of these frames (points in time where we figure out the pressure) per second.  First we'll compute all the times where we need a frame.

**Question 1.** Create an array called `frame_times`.  It should contain the frame times for the 3-second period.  That is, it should start with 0, then $1/44100$, then $2/44100$, and so on, ending just before $3$.

```{python}
# You'll find these names useful.
FRAMES_PER_SECOND = 44100
SOUND_DURATION = 3

frame_times = ...
frame_times
```

```{python}
_ = tests.grade('q1')
```

Now we need a way to synthesize air pressure numbers that go up and down 220 times per second.  It's customary to use the `sine` function to do that, since it's a nice function that oscillates.  For a sound that oscillates 220 times per second, the pressure at time $t$ is:

$$\text{Pressure at time }t = \texttt{sin}(2 \times \pi \times 220 \times t)$$

The function `np.sin` takes as its argument an array of times and returns an array that's the `sine` of each of those times.  For example,

    np.sin(make_array(0, 1, 2))

is the same as
    
    make_array(math.sin(0), math.sin(1), math.sin(2))

**Question 2.** Use `np.sin`, array arithmetic, and the `frame_times` array you generated above to generate the pressure on your ear at each frame.

```{python}
A_FREQUENCY = 220
a_pressures = ...
a_pressures
```

```{python}
_ = tests.grade('q2')
```

Here's a graph of 1000 frames of the data you generated, lasting around .025 seconds:

```{python}
# Just run this cell.  It uses some programming concepts you'll see in the
# next few weeks.
Table().with_columns("Frame time (s)", frame_times, "Pressure on ear", a_pressures).take(range(1000)).plot(0)
plt.ylim(-1.2, 1.2)
_ = plt.title("Pressure on ear over time (A below middle C)")
```

The peaks represent points in time when the pressure on your ear was high, and the troughs represent points in time when it was low.

##### Turning it into sounds
The function `Audio` (in the `IPython.display` module) takes pressure data and passes it to your computer's speakers to produce.  The speakers move rapidly (220 times per second, in this case), producing pressure changes in the air, and your ears interpret these as sound.

`Audio` takes two arguments.  The first is an array containing the pressures you want to generate, like your `pressures` array.  The second is the number of frames per second the data were taken at.  This argument is a *named* argument, which means you have to write `rate=` before it, like this:

    Audio(make_array(0, 1, 2), rate=120)

`Audio` returns an object that represents the sound it will play.  If it's the value of the last line in a cell, it will play when you run that cell.

**Question 3.** Import and call `Audio` to make a sound from your data.  Call it `a_below_middle_c`.

```{python}
# Warning: When you fill out this cell correctly, running it will
# cause a sound to play!
...
a_below_middle_c = ...
a_below_middle_c
```

```{python}
_ = tests.grade('q3')
```

##### Richer sounds
When two things make sounds at once, the pressures they put on your ear just add together.  So to play two sounds at once, we just *add their pressure values* at each frame.

**Question 4.** Create the pressure data for a sound that oscillates 277 times per second, calling it `c_sharp_pressures`, and a sound that oscillates 330 times per second, calling it `e_pressures`.  Add both of those arrays to `a_pressures`, producing an array called `chord_pressures`.  Then create a sound from that data, called `chord_sound`, and play it.  It's called an A-major chord.

```{python}
C_SHARP_FREQUENCY = 277
c_sharp_pressures = ...
E_FREQUENCY = 330
e_pressures = ...
chord_pressures = ...
chord_sound = ...
chord_sound
```

```{python}
_ = tests.grade('q4')
```

For a challenge, try changing the amount of pressure over time so you hear the volume increase over the 3-second period.  You can also change the rate of oscillations over time to change the notes you hear.  Real-world sounds, like human speech, are just combinations of many pitches that change very quickly.

```{python}
# For your convenience, you can run this cell to run all the tests at once!
import os
_ = [tests.grade(q[:-3]) for q in os.listdir("tests") if q.startswith('q')]
```

```{python}
# Run this cell to submit your work *after* you have passed all of the test cells.
# It's ok to run this cell multiple times. Only your final submission will be scored.

# !TZ=America/Los_Angeles ipython nbconvert --output=".making_sounds_$(date +%m%d_%H%M)_submission.html" making_sounds.ipynb
```
